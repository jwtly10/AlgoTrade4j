{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AlgoTrade4j","text":"<p>\ud83c\udfd7\ufe0f Note: This project is currently a work in progress and not yet ready for production live trading use \ud83c\udfd7\ufe0f</p>"},{"location":"#introduction","title":"Introduction","text":"<p>AlgoTrade4j is a high-performance, comprehensive algorithmic trading platform designed for Java developers. Originally conceived to port strategies from MQL (MetaTrader4) to Java, it has evolved into a robust and flexible system capable of strategy development, backtesting, and live trading.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>High Performance: Processes up to 50,000 ticks per second.</li> <li>Asynchronous Architecture: Event-driven design ensures responsive strategy execution.</li> <li>Flexible Data Integration: Clean interfaces for fetching bar data from multiple external providers.</li> <li>Advanced Backtesting: Synthetic tick generation from bar data for enhanced price movement granularity.</li> <li>Real-time Updates: WebSocket support and event publishers for live data streaming.</li> <li>REST APIs: Seamless external integrations for extended functionality.</li> <li>Comprehensive Testing: Extensive test coverage for reliability.</li> <li>Integrated Frontend: React-based UI for strategy management and execution.</li> <li>Dynamic Configuration: Annotation-based system for flexible strategy parameterization.</li> <li>Optimization Tools: Advanced utilities for efficient backtesting and strategy optimization.</li> <li>Robust Security: Integrated authentication and authorization system.</li> <li>Scalable Architecture: Separate services for backtesting and live trading, supporting independent scaling.</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>AlgoTrade4j consists of five main components:</p> <ol> <li>Core Module: Contains the main trading logic, event system, and implemented defaults.</li> <li>Backtest API Module: A Spring REST API for handling backtesting operations and core system functions.</li> <li>Live API Module: A Spring service for live trading and broker-related operations.</li> <li>Market Data Module: Manages integration with external market data providers.</li> <li>React Frontend Module: Provides a user interface for interacting with the system.</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To begin using AlgoTrade4j, you'll want to familiarize yourself with:</p> <ul> <li>Creating Strategies: Learn how to implement your trading algorithms.</li> <li>Configuring Parameters: Understand how to use the <code>@Parameter</code> annotation for dynamic strategy configuration.</li> <li>Using Indicators: Explore how to create and use technical indicators in your strategies.</li> <li>Backtesting: Learn how to test your strategies against historical data.</li> <li>Optimisation: Learn how to optimise your strategies.</li> <li>Live Trading: Understand how to deploy your strategies in a live trading environment.</li> </ul>"},{"location":"#development-and-deployment","title":"Development and Deployment","text":"<p>Guides coming soon</p>"},{"location":"#important-notes","title":"Important Notes","text":"<p>\u26a0\ufe0f AlgoTrade4j is a bespoke implementation and may not be suitable for all use cases. Always thoroughly test strategies before live deployment and use at your own risk.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>While AlgoTrade4j implements many key features of a trading platform there are some limitations:</p>"},{"location":"limitations/#hft","title":"HFT:","text":"<ul> <li>The platform is profiled, well tested and optimisation for performance, but HFT is not a goal of the platform. While you may have success with HFT strategies, the platform is not designed for this use case, and there will be edge cases where the platform may not be suitable.</li> <li>The system has not been stress tested for HFT strategies, and issues may arise under high load, which will not be addressed for now.</li> </ul>"},{"location":"limitations/#live-trading","title":"Live Trading:","text":"<ul> <li>While being used internally, the live trading service is not mature enough yet to assure an error-free experience.</li> <li>It's recommended to not yet use the live service for real funds, and we take no responsibility for any errors which may cause you to lose money.</li> <li>It's recommend to use the backtesting application to quickly test over millions of data points, and reimplement your strategy in a supported platform.</li> </ul>"},{"location":"frontend/backtesting/","title":"Backtesting","text":"<p>(TODO) Demo coming soon.</p> <p></p>"},{"location":"frontend/live-trading/","title":"Live Trading","text":"<p>(TODO) Demo coming soon.</p> <p></p>"},{"location":"frontend/optimisation/","title":"Optimisation","text":"<p>(TODO) Demo coming soon.</p> <p></p>"},{"location":"frontend/overview/","title":"Overview","text":"<p>(TODO) Demo coming soon.</p>"},{"location":"lib/user-guide/","title":"User Guide: Creating New Strategies","text":""},{"location":"lib/user-guide/#overview","title":"Overview","text":"<p>This guide will walk you through the process of creating a new trading strategy in AlgoTrade4j. Strategies in AlgoTrade4j extend the <code>BaseStrategy</code> class, which provides a rich set of utilities and abstractions for common trading operations.</p>"},{"location":"lib/user-guide/#prerequisites","title":"Prerequisites","text":"<p>Before creating a new strategy, ensure you're familiar with:</p> <ul> <li>Java programming</li> <li>Basic concepts of algorithmic trading</li> <li>AlgoTrade4j's <code>BaseStrategy</code> class and its methods</li> </ul>"},{"location":"lib/user-guide/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"lib/user-guide/#1-create-a-new-class","title":"1. Create a New Class","text":"<p>Start by creating a new Java class that extends <code>BaseStrategy</code>:</p> <pre><code>import dev.jwtly10.core.strategy.BaseStrategy;\n\npublic class MyNewStrategy extends BaseStrategy {\n    public MyNewStrategy() {\n        super(\"MyNewStrategyID\");\n    }\n}\n</code></pre>"},{"location":"lib/user-guide/#2-define-strategy-parameters","title":"2. Define Strategy Parameters","text":"<p>Use the <code>@Parameter</code> annotation to define configurable parameters for your strategy:</p> <pre><code>import dev.jwtly10.core.strategy.Parameter;\n\n@Parameter(name = \"stopLossTicks\", description = \"Tick size of the stop loss\", value = \"300\", group = \"Risk\")\nprivate int stopLossTicks;\n\n@Parameter(name = \"riskRatio\", description = \"Risk ratio of SL to TP\", value = \"5\", group = \"Risk\")\nprivate int riskRatio;\n\n@Parameter(name = \"shortSMALength\", description = \"Length of short-term SMA\", value = \"50\", group = \"Indicator\")\nprivate int shortSMALength;\n</code></pre> <p>Parameters can be grouped for better organization. The value field sets the default value.</p>"},{"location":"lib/user-guide/#3-initialize-indicators","title":"3. Initialize Indicators","text":"<p>Override the <code>initIndicators()</code> method to create and initialize your strategy's indicators:</p> <pre><code>\n@Override\nprotected void initIndicators() {\n    shortSMA = createIndicator(iSMA.class, shortSMALength);\n    atrIndicator = createIndicator(iATRCandle.class, atrLength, atrSensitivity, relativeSize);\n}\n</code></pre> <p>Use the <code>createIndicator()</code> method provided by BaseStrategy to instantiate indicators.</p>"},{"location":"lib/user-guide/#4-implement-required-methods","title":"4. Implement Required Methods","text":"<p>At a minimum, you need to implement the following methods:</p> <pre><code>\n@Override\npublic void onTick(Tick tick, Bar currentBar) {\n// React to each new tick\n}\n\n@Override\npublic void onBarClose(Bar bar) {\n// Implement your main strategy logic here\n}\n\n@Override\npublic RiskProfileConfig getRiskProfileConfig() {\n    return riskProfile.getConfig();\n}\n</code></pre>"},{"location":"lib/user-guide/#5-implement-strategy-logic","title":"5. Implement Strategy Logic","text":"<p>In the onBarClose/onTickMethod method, implement your strategy's core logic. This typically involves:</p> <ol> <li>Checking if indicators are ready</li> <li>Evaluating entry conditions</li> <li>Opening trades if conditions are met</li> </ol> <p>Or any other custom ideas you may have</p> <p>Example:</p> <pre><code>\n@Override\npublic void onBarClose(Bar bar) {\n    if (isReady() &amp;&amp; isTimeToTrade(bar)) {\n        if (entryCheck(bar, true)) {\n            var id = openLong(createTradeParameters(true));\n            sendNotification(String.format(\"Opened long trade %s @  %s\", id, Ask()));\n        } else if (entryCheck(bar, false)) {\n            var id = openShort(createTradeParameters(false));\n            sendNotification(String.format(\"Opened short trade %s @ %s\", id, Bid()));\n        }\n    }\n}\n</code></pre>"},{"location":"lib/user-guide/#6-utilize-basestrategy-methods","title":"6. Utilize BaseStrategy Methods","text":"<p>Make use of the methods provided by<code>BaseStrategy</code>:</p> <p>Here are a few main ones:</p> <ul> <li><code>openLong()</code> and <code>openShort()</code> for opening trades</li> <li><code>Ask()</code> and <code>Bid()</code> for current market prices</li> <li><code>sendNotification()</code> for sending alerts</li> <li><code>getStopLossGivenInstrumentPriceDir()</code> for calculating stop loss prices without any manual calcs</li> </ul>"},{"location":"lib/user-guide/#conclusion","title":"Conclusion","text":"<p>By following this guide, you should be able to create a new strategy that leverages the power of AlgoTrade4j's BaseStrategy, and its platform.</p>"},{"location":"lib/user-guide/#examples","title":"Examples","text":"<p>SMACrossoverStrategy</p>"},{"location":"lib/components/base-strategy/","title":"BaseStrategy","text":""},{"location":"lib/components/base-strategy/#overview","title":"Overview","text":"<p>The <code>BaseStrategy</code> class is a fundamental component of the AlgoTrade4j framework. It serves as an abstract base class for all trading strategies, providing a rich set of methods and utilities that abstract away common trading functionalities. By extending this class, strategy developers can focus on implementing their specific trading logic while leveraging the robust infrastructure provided by AlgoTrade4j.</p>"},{"location":"lib/components/base-strategy/#key-features","title":"Key Features","text":"<ul> <li>Abstracts away complex trading operations</li> <li>Provides easy access to market data and account information</li> <li>Offers utility methods for common trading calculations</li> <li>Manages strategy parameters and indicators</li> <li>Handles lifecycle events of a trading strategy</li> </ul>"},{"location":"lib/components/base-strategy/#methods-for-strategy-implementation","title":"Methods for Strategy Implementation","text":""},{"location":"lib/components/base-strategy/#trade-management","title":"Trade Management","text":""},{"location":"lib/components/base-strategy/#openlongtradeparameters-params","title":"<code>openLong(TradeParameters params)</code>","text":"<ul> <li>Description: Opens a long position with the specified trade parameters.</li> <li>Returns: Integer (trade ID)</li> <li>Note: Returns -1 if the trade is not allowed by the risk manager.</li> </ul>"},{"location":"lib/components/base-strategy/#openshorttradeparameters-params","title":"<code>openShort(TradeParameters params)</code>","text":"<ul> <li>Description: Opens a short position with the specified trade parameters.</li> <li>Returns: Integer (trade ID)</li> <li>Note: Returns -1 if the trade is not allowed by the risk manager.</li> </ul>"},{"location":"lib/components/base-strategy/#createtradeparametersinstrument-instrument-int-stoplossticks-boolean-islong-double-riskratio-double-riskpercentage-double-balancetorisk","title":"<code>createTradeParameters(Instrument instrument, int stopLossTicks, boolean isLong, double riskRatio, double riskPercentage, double balanceToRisk)</code>","text":"<ul> <li>Description: Automatically creates a new TradeParameters object based on the strategy's risk management settings.</li> <li>Returns: TradeParameters</li> <li>Note: This is the recommended way to create trade parameters for a trade. All trades in a strategy should open trades based on a given risk ratio, given a defined tick size, to ensure consistency.</li> </ul>"},{"location":"lib/components/base-strategy/#account-information","title":"Account Information","text":""},{"location":"lib/components/base-strategy/#getinitialbalance","title":"<code>getInitialBalance()</code>","text":"<ul> <li>Description: Returns the initial balance of the account.</li> <li>Returns: double</li> </ul>"},{"location":"lib/components/base-strategy/#getbalance","title":"<code>getBalance()</code>","text":"<ul> <li>Description: Returns the current balance of the account.</li> <li>Returns: double</li> </ul>"},{"location":"lib/components/base-strategy/#getequity","title":"<code>getEquity()</code>","text":"<ul> <li>Description: Returns the current equity of the account.</li> <li>Returns: double</li> </ul>"},{"location":"lib/components/base-strategy/#market-data-access","title":"Market Data Access","text":""},{"location":"lib/components/base-strategy/#getlastbar","title":"<code>getLastBar()</code>","text":"<ul> <li>Description: Returns the last bar in the series.</li> <li>Returns: Bar</li> </ul>"},{"location":"lib/components/base-strategy/#getbarint-index","title":"<code>getBar(int index)</code>","text":"<ul> <li>Description: Returns the bar at the specified index.</li> <li>Returns: Bar</li> </ul>"},{"location":"lib/components/base-strategy/#ask","title":"<code>Ask()</code>","text":"<ul> <li>Description: Returns the current ask price.</li> <li>Returns: Number</li> </ul>"},{"location":"lib/components/base-strategy/#bid","title":"<code>Bid()</code>","text":"<ul> <li>Description: Returns the current bid price.</li> <li>Returns: Number</li> </ul>"},{"location":"lib/components/base-strategy/#utility-methods","title":"Utility Methods","text":""},{"location":"lib/components/base-strategy/#usesystemnotifications","title":"<code>useSystemNotifications()</code>","text":""},{"location":"lib/components/base-strategy/#-description-turns-on-the-use-of-system-notifications-for-a-strategy-system-notifications-are-configured-at-the-instance-level-and-used-for-247-monitoring-of-the-strategy","title":"- Description: Turns on the use of system notifications for a strategy. System notifications are configured at the instance level and used for 24/7 monitoring of the strategy.","text":""},{"location":"lib/components/base-strategy/#usecustomnotifications","title":"<code>useCustomNotifications()</code>","text":"<ul> <li>Description: Turns on the use of custom developer created notifications for a strategy.</li> </ul>"},{"location":"lib/components/base-strategy/#getstoplossgiveninstrumentpricedirinstrument-instrument-number-price-int-ticks-boolean-islong","title":"<code>getStopLossGivenInstrumentPriceDir(Instrument instrument, Number price, int ticks, boolean isLong)</code>","text":"<ul> <li>Description: Calculates the stop loss price based on the given parameters.</li> <li>Returns: Number</li> </ul>"},{"location":"lib/components/base-strategy/#sendcustomnotificationstring-message","title":"<code>sendCustomNotification(String message)</code>","text":"<ul> <li>Description: Sends a notification message to the external notifier implementation. Uses the live strategies chatId configuration item.</li> </ul>"},{"location":"lib/components/base-strategy/#indicator-management","title":"Indicator Management","text":""},{"location":"lib/components/base-strategy/#createindicatorclasst-indicatorclass-object-params","title":"<code>createIndicator(Class&lt;T&gt; indicatorClass, Object... params)</code>","text":"<ul> <li>Description: Factory method for creating indicators.</li> <li>Returns: T (the created indicator)</li> </ul>"},{"location":"lib/components/base-strategy/#parameter-management","title":"Parameter Management","text":""},{"location":"lib/components/base-strategy/#setparametersmapstring-string-parameters","title":"<code>setParameters(Map&lt;String, String&gt; parameters)</code>","text":"<ul> <li>Description: Sets the parameters of the strategy.</li> </ul>"},{"location":"lib/components/base-strategy/#getcurrentparameters","title":"<code>getCurrentParameters()</code>","text":"<ul> <li>Description: Returns the current parameters of the strategy.</li> <li>Returns: Map"},{"location":"lib/components/base-strategy/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>The BaseStrategy class provides several lifecycle methods that can be overridden by strategy implementations:</p>"},{"location":"lib/components/base-strategy/#onstart","title":"<code>onStart()</code>","text":"<ul> <li>Description: Custom initialization method called after indicators are initialized but before the strategy starts processing bars.</li> </ul>"},{"location":"lib/components/base-strategy/#onticktick-tick-bar-currentbar","title":"<code>onTick(Tick tick, Bar currentBar)</code>","text":"<ul> <li>Description: Called on each tick. Here you can define your strategy logic that runs on each tick.</li> </ul>"},{"location":"lib/components/base-strategy/#onbarclosebar-bar","title":"<code>onBarClose(Bar bar)</code>","text":"<ul> <li>Description: Called when a bar closes. Here you can define your strategy logic that runs on each bar close.</li> </ul>"},{"location":"lib/components/base-strategy/#ontradeclosetrade-trade","title":"<code>onTradeClose(Trade trade)</code>","text":"<ul> <li>Description: Called when trade is closed. Some internal logic runs but this can be overridden to add custom logic.</li> </ul>"},{"location":"lib/components/base-strategy/#onnewdayzoneddatetime-newday","title":"<code>onNewDay(ZonedDateTime newDay)</code>","text":"<ul> <li>Description: Called at the start of each new trading day. Here you can define your strategy logic that runs at the start of each new day.</li> </ul>"},{"location":"lib/components/base-strategy/#onend","title":"<code>onEnd()</code>","text":"<ul> <li>Description: Called when the strategy processing ends. Use this for cleanup or final calculations.</li> </ul>"},{"location":"lib/components/base-strategy/#abstracted-functionality","title":"Abstracted Functionality","text":"<p>The BaseStrategy class abstracts away several complex operations:</p> <ol> <li>Data Management: Provides easy access to market data through the DataManager.</li> <li>Account Management: Handles account-related operations via the AccountManager.</li> <li>Trade Execution: Manages trade execution through the TradeManager.</li> <li>Event Handling: Utilizes an EventPublisher for system-wide event management.</li> <li>Performance Analysis: Integrates with a PerformanceAnalyser for strategy evaluation.</li> <li>Risk Management: Incorporates risk management checks when opening trades.</li> <li>Indicator Handling: Manages the creation and initialization of technical indicators.</li> <li>Parameter Management: Handles strategy parameter initialization and updates.</li> </ol> <p>By extending the BaseStrategy class, developers can create sophisticated trading strategies while focusing on their core trading logic, leaving the complexities of system integration and management to the AlgoTrade4j framework.</p>"},{"location":"lib/components/indicators/","title":"Indicators in AlgoTrade4j","text":""},{"location":"lib/components/indicators/#overview","title":"Overview","text":"<p>Indicators are essential tools in technical analysis, used to analyze price movements and trends in financial markets. In AlgoTrade4j, indicators are implemented as classes that conform to the <code>Indicator</code> interface.</p>"},{"location":"lib/components/indicators/#the-indicator-interface","title":"The Indicator Interface","text":"<p>The <code>Indicator</code> interface defines the core functionality that all indicators must implement:</p> <pre><code>public interface Indicator {\n    List&lt;IndicatorValue&gt; getValues();\n\n    void update(Bar bar);\n\n    double getValue();\n\n    double getValue(int index);\n\n    String getName();\n\n    boolean isReady();\n\n    int getRequiredPeriods();\n\n    void setEventPublisher(EventPublisher eventPublisher);\n\n    void setStrategyId(String strategyId);\n}\n</code></pre>"},{"location":"lib/components/indicators/#implementing-a-custom-indicator","title":"Implementing a Custom Indicator","text":"<p>To create a custom indicator, follow these steps:</p> <ul> <li>Create a new class that implements the Indicator interface.</li> <li>Implement all required methods.</li> <li>Add any additional fields or methods specific to your indicator.</li> </ul>"},{"location":"lib/components/indicators/#example-simple-moving-average-sma-indicator","title":"Example: Simple Moving Average (SMA) Indicator","text":"<p>Here's a simplified example of how to implement a Simple Moving Average (SMA) indicator:</p> <pre><code>public class iSMA implements Indicator {\nprivate final int period;\nprivate final List&lt;Double&gt; rawValues;\nprivate final List&lt;IndicatorValue&gt; values;\nprivate final String name;\nprivate String strategyId;\nprivate EventPublisher eventPublisher;\n\n    public iSMA(int period) {\n        this.period = period;\n        this.rawValues = new ArrayList&lt;&gt;();\n        this.values = new ArrayList&lt;&gt;();\n        this.name = \"SMA \" + period;\n    }\n\n    @Override\n    public void update(Bar bar) {\n        rawValues.add(bar.getClose().getValue().doubleValue());\n        if (isReady()) {\n            double sum = rawValues.subList(rawValues.size() - period, rawValues.size())\n                    .stream().mapToDouble(Double::doubleValue).sum();\n            double average = sum / period;\n            IndicatorValue indicatorValue = new IndicatorValue(average, bar.getOpenTime());\n            values.add(indicatorValue);\n            if (eventPublisher != null) {\n                eventPublisher.publishEvent(new IndicatorEvent(strategyId, bar.getInstrument(), getName(), indicatorValue));\n            }\n        }\n    }\n\n    @Override\n    public double getValue() {\n        return values.isEmpty() ? 0 : values.get(values.size() - 1).getValue();\n    }\n\n    // Implement other methods...\n\n}\n</code></pre>"},{"location":"lib/components/indicators/#key-considerations","title":"Key Considerations","text":"<p>When implementing a custom indicator, keep the following in mind:</p> <ul> <li>Performance: Indicators are updated frequently. Ensure your implementation is efficient, especially for computationally intensive indicators.</li> <li>Accuracy: Double-check your calculations against known good implementations to ensure accuracy.</li> <li>Event Publishing: Use the eventPublisher to notify the system of new indicator values. This is crucial for real-time updates and visualization.</li> <li>Initialization: Handle the case where there's not enough data to calculate the indicator value (before isReady() returns true).</li> <li>Historical Values: Implement getValue(int index) correctly to allow strategies to access past indicator values.</li> <li>Threading: Ensure your indicator is thread-safe if it will be used in a multi-threaded environment.</li> </ul>"},{"location":"lib/components/indicators/#using-custom-indicators-in-strategies","title":"Using Custom Indicators in Strategies","text":"<p>To use your custom indicator in a strategy:</p> <p>1, Create the indicator in your strategy's initIndicators() method:</p> <pre><code>\n@Override\nprotected void initIndicators() {\n    smaIndicator = createIndicator(iSMA.class, 14);\n}\n</code></pre> <p>2, Use the indicator in your strategy logic:</p> <pre><code>\n@Override\npublic void onBarClose(Bar bar) {\n    if (smaIndicator.isReady()) {\n        double smaValue = smaIndicator.getValue();\n// Your strategy logic here\n    }\n}\n</code></pre>"},{"location":"lib/components/indicators/#built-in-indicators","title":"Built-in Indicators","text":"<p>AlgoTrade4j comes with several built-in indicators. You can find these in the <code>dev.jwtly10.core.indicators</code> package. These serve as examples and can be used directly in your strategies.</p>"},{"location":"lib/components/indicators/#best-practices","title":"Best Practices","text":"<ul> <li>Name your indicator classes with a lowercase 'i' prefix (e.g., <code>iSMA</code>, <code>iRSI</code>) for consistency with built-in indicators.</li> <li>Document your indicator thoroughly, especially if it involves complex calculations.</li> <li>Write unit tests for your indicators to ensure they behave correctly under various market conditions.</li> </ul> <p>By following these guidelines, you can create custom indicators for use in your AlgoTrade4j strategies.</p>"},{"location":"lib/components/parameters/","title":"Parameter Annotation","text":"<p>The <code>@Parameter</code> annotation is a crucial component in defining configurable parameters for trading strategies in AlgoTrade4j. It allows for dynamic configuration and optimization of strategy parameters.</p> <p>You can of course define your own variables in the strategy class, but they will not have access to the runtime dynamic updates that <code>@Parameter</code> annotated variables do.</p>"},{"location":"lib/components/parameters/#purpose","title":"Purpose","text":"<p>The <code>@Parameter</code> annotation serves several important purposes:</p> <ol> <li>Strategy Configuration: It defines parameters that can be adjusted when initializing or running a strategy.</li> <li>Optimization: It allows the optimizer to access and modify strategy parameters during backtesting and optimization processes.</li> <li>UI Integration: It provides metadata for generating user interfaces for strategy configuration.</li> </ol>"},{"location":"lib/components/parameters/#usage","title":"Usage","text":"<p>To use the <code>@Parameter</code> annotation, apply it to fields in your strategy class that you want to make configurable. The annotation takes several arguments to define the parameter's properties.</p>"},{"location":"lib/components/parameters/#example","title":"Example","text":"<pre><code>public class MyStrategy extends BaseStrategy {\n    @Parameter(name = \"stopLossTicks\", description = \"Tick size of the stop loss\", value = \"300\", group = \"Risk\")\n    private int stopLossTicks;\n\n    @Parameter(name = \"riskRatio\", description = \"Risk ratio of SL to TP\", value = \"5\", group = \"Risk\")\n    private int riskRatio;\n\n    @Parameter(name = \"riskPercentage\", description = \"Percentage of balance to risk per trade\", value = \"1\", group = \"Risk\")\n    private double riskPercentage;\n\n    @Parameter(name = \"balanceToRisk\", description = \"Balance to risk (static)\", value = \"10000\", group = \"Risk\")\n    private double balanceToRisk;\n\n    @Parameter(name = \"riskProfile\", description = \"Risk profile to use\", value = \"NONE\", enumClass = RiskProfile.class, group = \"Risk\")\n    private RiskProfile riskProfile;\n\n    // Strategy implementation...\n}\n</code></pre>"},{"location":"lib/components/parameters/#annotation-properties","title":"Annotation Properties","text":"<ul> <li>name: The name of the parameter. It should match the variable name it's annotating.</li> <li>description: A brief description of the parameter's purpose or effect.</li> <li>value: The default value of the parameter.</li> <li>group: Used for UI customization and parameter organization.</li> <li>enumClass: Specifies the enum class if the parameter is an enumeration type.</li> </ul>"},{"location":"lib/components/parameters/#important-notes","title":"Important Notes","text":"<ul> <li>The name property should match the variable name it's annotating. This is used to match the parameter to the variable during runtime configuration.</li> <li>The ParameterHandler class in AlgoTrade4j uses reflection to process these annotations, allowing for dynamic parameter handling and validation.</li> <li>Parameters can be of various types including int, double, boolean, String, and custom enum types, which all will be validated during runtime.</li> </ul>"},{"location":"lib/components/parameters/#benefits","title":"Benefits","text":"<ul> <li>Flexibility: Easily adjust strategy behavior without modifying code.</li> <li>Optimization: Enables automated parameter tuning during backtesting.</li> <li>User-Friendly: Facilitates the creation of intuitive UIs for strategy configuration.</li> <li>Standardization: Provides a consistent way to define and handle strategy parameters across different strategies.</li> </ul>"}]}